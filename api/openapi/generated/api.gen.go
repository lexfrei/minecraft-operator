//go:build go1.22

// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package generated

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"time"

	"github.com/oapi-codegen/runtime"
	strictnethttp "github.com/oapi-codegen/runtime/strictmiddleware/nethttp"
)

// Defines values for ConditionStatus.
const (
	ConditionStatusFalse   ConditionStatus = "False"
	ConditionStatusTrue    ConditionStatus = "True"
	ConditionStatusUnknown ConditionStatus = "Unknown"
)

// Defines values for ErrorResponseCode.
const (
	ALREADYEXISTS  ErrorResponseCode = "ALREADY_EXISTS"
	FORBIDDEN      ErrorResponseCode = "FORBIDDEN"
	INTERNALERROR  ErrorResponseCode = "INTERNAL_ERROR"
	INVALIDREQUEST ErrorResponseCode = "INVALID_REQUEST"
	NOTFOUND       ErrorResponseCode = "NOT_FOUND"
	UNAUTHORIZED   ErrorResponseCode = "UNAUTHORIZED"
)

// Defines values for HealthResponseStatus.
const (
	Healthy   HealthResponseStatus = "healthy"
	Unhealthy HealthResponseStatus = "unhealthy"
)

// Defines values for LabelSelectorRequirementOperator.
const (
	DoesNotExist LabelSelectorRequirementOperator = "DoesNotExist"
	Exists       LabelSelectorRequirementOperator = "Exists"
	In           LabelSelectorRequirementOperator = "In"
	NotIn        LabelSelectorRequirementOperator = "NotIn"
)

// Defines values for PluginSourceType.
const (
	Hangar PluginSourceType = "hangar"
	Url    PluginSourceType = "url"
)

// Defines values for RepositoryStatus.
const (
	Available   RepositoryStatus = "available"
	Orphaned    RepositoryStatus = "orphaned"
	Unavailable RepositoryStatus = "unavailable"
)

// Defines values for ServerStatus.
const (
	ServerStatusRunning  ServerStatus = "running"
	ServerStatusUnknown  ServerStatus = "unknown"
	ServerStatusUpdating ServerStatus = "updating"
)

// Defines values for ServiceType.
const (
	ClusterIP    ServiceType = "ClusterIP"
	LoadBalancer ServiceType = "LoadBalancer"
	NodePort     ServiceType = "NodePort"
)

// Defines values for UpdateStrategy.
const (
	Auto     UpdateStrategy = "auto"
	BuildPin UpdateStrategy = "build-pin"
	Latest   UpdateStrategy = "latest"
	Pin      UpdateStrategy = "pin"
)

// ActionResponse Response for action endpoints
type ActionResponse struct {
	// Message Human-readable result message
	Message string `json:"message"`

	// Timestamp When the action was triggered
	Timestamp *time.Time `json:"timestamp,omitempty"`
}

// AvailableUpdate Information about an available update
type AvailableUpdate struct {
	// Build Available Paper build number
	Build *int `json:"build,omitempty"`

	// FoundAt When this update was discovered
	FoundAt *time.Time `json:"foundAt,omitempty"`

	// Plugins Plugin versions for this update
	Plugins *[]PluginVersionPair `json:"plugins,omitempty"`

	// ReleasedAt When this version was released
	ReleasedAt *time.Time `json:"releasedAt,omitempty"`

	// Version Available Paper version
	Version *string `json:"version,omitempty"`
}

// BlockedByInfo Details about what is blocking an update
type BlockedByInfo struct {
	// Plugin Name of the blocking plugin
	Plugin *string `json:"plugin,omitempty"`

	// SupportedVersions Minecraft versions this plugin supports
	SupportedVersions *[]string `json:"supportedVersions,omitempty"`

	// Version Version of the blocking plugin
	Version *string `json:"version,omitempty"`
}

// CompatibilityOverride Manual compatibility specification
type CompatibilityOverride struct {
	// Enabled Whether to use override instead of API metadata
	Enabled *bool `json:"enabled,omitempty"`

	// MinecraftVersions Supported Minecraft versions
	MinecraftVersions *[]string `json:"minecraftVersions,omitempty"`
}

// Condition Kubernetes condition
type Condition struct {
	// LastTransitionTime When the condition last changed
	LastTransitionTime *time.Time `json:"lastTransitionTime,omitempty"`

	// Message Human-readable message
	Message *string `json:"message,omitempty"`

	// ObservedGeneration Generation of the resource when condition was set
	ObservedGeneration *int64 `json:"observedGeneration,omitempty"`

	// Reason Machine-readable reason for the condition
	Reason *string `json:"reason,omitempty"`

	// Status Status of a condition (True, False, or Unknown)
	Status ConditionStatus `json:"status"`

	// Type Condition type
	Type string `json:"type"`
}

// ConditionStatus Status of a condition (True, False, or Unknown)
type ConditionStatus string

// DeletionProgressEntry JAR cleanup progress for a server
type DeletionProgressEntry struct {
	// DeletedAt When the JAR was deleted
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// JarDeleted Whether the JAR has been deleted
	JarDeleted bool `json:"jarDeleted"`

	// Namespace Server namespace
	Namespace string `json:"namespace"`

	// ServerName Server name
	ServerName string `json:"serverName"`
}

// ErrorResponse Error response body
type ErrorResponse struct {
	// Code Machine-readable error code
	Code *ErrorResponseCode `json:"code,omitempty"`

	// Details Additional error details
	Details *map[string]interface{} `json:"details,omitempty"`

	// Error Human-readable error message
	Error string `json:"error"`
}

// ErrorResponseCode Machine-readable error code
type ErrorResponseCode string

// HealthResponse Health check response
type HealthResponse struct {
	// Error Error message if unhealthy
	Error *string `json:"error,omitempty"`

	// Status Health status of the API server
	Status HealthResponseStatus `json:"status"`

	// Timestamp Timestamp when health check was performed
	Timestamp time.Time `json:"timestamp"`
}

// HealthResponseStatus Health status of the API server
type HealthResponseStatus string

// LabelSelector Kubernetes label selector
type LabelSelector struct {
	// MatchExpressions Label selector expressions
	MatchExpressions *[]LabelSelectorRequirement `json:"matchExpressions,omitempty"`

	// MatchLabels Labels that must match exactly
	MatchLabels *map[string]string `json:"matchLabels,omitempty"`
}

// LabelSelectorRequirement A label selector requirement
type LabelSelectorRequirement struct {
	// Key Label key
	Key string `json:"key"`

	// Operator Operator (In, NotIn, Exists, DoesNotExist)
	Operator LabelSelectorRequirementOperator `json:"operator"`

	// Values Values for In/NotIn operators
	Values *[]string `json:"values,omitempty"`
}

// LabelSelectorRequirementOperator Operator (In, NotIn, Exists, DoesNotExist)
type LabelSelectorRequirementOperator string

// MaintenanceSchedule Maintenance schedule configuration
type MaintenanceSchedule struct {
	// CheckCron Cron expression for update checks
	CheckCron *string `json:"checkCron,omitempty"`

	// Enabled Whether maintenance window is enabled
	Enabled *bool `json:"enabled,omitempty"`

	// NextWindow Human-readable next maintenance window
	NextWindow *string `json:"nextWindow,omitempty"`

	// WindowCron Cron expression for maintenance window
	WindowCron *string `json:"windowCron,omitempty"`
}

// MaintenanceWindowConfig Maintenance window configuration for create/update requests
type MaintenanceWindowConfig struct {
	// Cron Cron expression for maintenance window
	Cron *string `json:"cron,omitempty"`

	// Enabled Whether to enable maintenance window
	Enabled *bool `json:"enabled,omitempty"`
}

// MatchedInstance A server instance matched by the plugin's instance selector
type MatchedInstance struct {
	// Compatible Whether the plugin is compatible with this server
	Compatible bool `json:"compatible"`

	// Name Server resource name
	Name string `json:"name"`

	// Namespace Server namespace
	Namespace string `json:"namespace"`

	// Version Server's current Paper version
	Version *string `json:"version,omitempty"`
}

// NamespaceListResponse defines model for NamespaceListResponse.
type NamespaceListResponse struct {
	// Namespaces List of namespace names
	Namespaces []string `json:"namespaces"`
}

// PluginCreateRequest Request body for creating a new Plugin
type PluginCreateRequest struct {
	// Build Pinned build number (for build-pin strategy)
	Build *int `json:"build,omitempty"`

	// CompatibilityOverride Manual compatibility specification
	CompatibilityOverride *CompatibilityOverride `json:"compatibilityOverride,omitempty"`

	// InstanceSelector Kubernetes label selector
	InstanceSelector LabelSelector `json:"instanceSelector"`

	// Name Kubernetes resource name
	Name string `json:"name"`

	// Namespace Kubernetes namespace
	Namespace string `json:"namespace"`

	// Port Network port to expose via Service
	Port *int `json:"port,omitempty"`

	// Source Plugin source configuration
	Source PluginSource `json:"source"`

	// UpdateDelay Grace period before applying updates
	UpdateDelay *string `json:"updateDelay,omitempty"`

	// UpdateStrategy Defines how versions are managed for servers and plugins.
	//
	// - **latest**: Always use the latest available version from the repository
	// - **auto**: Use constraint solver to find best version compatible with all dependencies
	// - **pin**: Pin to specific version, auto-update to latest build within that version
	// - **build-pin**: Pin to specific version AND build number, no automatic updates
	UpdateStrategy *UpdateStrategy `json:"updateStrategy,omitempty"`

	// Version Pinned version (required for pin/build-pin strategies)
	Version *string `json:"version,omitempty"`
}

// PluginDetail defines model for PluginDetail.
type PluginDetail struct {
	// AvailableVersions Cached version metadata from repository
	AvailableVersions *[]PluginVersion `json:"availableVersions,omitempty"`

	// Build Pinned build number (for build-pin strategy)
	Build *int `json:"build,omitempty"`

	// CompatibilityOverride Manual compatibility specification
	CompatibilityOverride *CompatibilityOverride `json:"compatibilityOverride,omitempty"`

	// Conditions Kubernetes conditions for the plugin
	Conditions *[]Condition `json:"conditions,omitempty"`

	// DeletionProgress JAR cleanup progress during plugin deletion
	DeletionProgress *[]DeletionProgressEntry `json:"deletionProgress,omitempty"`

	// InstanceSelector Kubernetes label selector
	InstanceSelector *LabelSelector `json:"instanceSelector,omitempty"`

	// LastFetched When metadata was last fetched from repository
	LastFetched *time.Time `json:"lastFetched,omitempty"`

	// MatchedInstances List of servers this plugin is matched to
	MatchedInstances *[]MatchedInstance `json:"matchedInstances,omitempty"`

	// MatchedServers Number of servers this plugin is matched to
	MatchedServers *int `json:"matchedServers,omitempty"`

	// Name Kubernetes resource name
	Name string `json:"name"`

	// Namespace Kubernetes namespace
	Namespace string `json:"namespace"`

	// Port Network port exposed by the plugin (added to Service)
	Port *int `json:"port,omitempty"`

	// Project Project identifier in the repository
	Project *string `json:"project,omitempty"`

	// RepositoryStatus Status of the plugin repository connection.
	//
	// - **available**: Repository is accessible and returning metadata
	// - **unavailable**: Repository is temporarily unavailable (using cached data)
	// - **orphaned**: Plugin source no longer exists in repository
	RepositoryStatus *RepositoryStatus `json:"repositoryStatus,omitempty"`

	// ResolvedVersion Version resolved by the constraint solver
	ResolvedVersion *string `json:"resolvedVersion,omitempty"`

	// SourceType Type of plugin repository.
	//
	// - **hangar**: PaperMC Hangar repository (hangar.papermc.io)
	// - **url**: Direct URL download (no version management)
	SourceType PluginSourceType `json:"sourceType"`

	// UpdateDelay Grace period before applying updates
	UpdateDelay *string `json:"updateDelay,omitempty"`

	// UpdateStrategy Defines how versions are managed for servers and plugins.
	//
	// - **latest**: Always use the latest available version from the repository
	// - **auto**: Use constraint solver to find best version compatible with all dependencies
	// - **pin**: Pin to specific version, auto-update to latest build within that version
	// - **build-pin**: Pin to specific version AND build number, no automatic updates
	UpdateStrategy UpdateStrategy `json:"updateStrategy"`

	// Url Direct download URL (for type=url)
	Url *string `json:"url,omitempty"`

	// Version Pinned version (for pin/build-pin strategies)
	Version *string `json:"version,omitempty"`
}

// PluginListResponse defines model for PluginListResponse.
type PluginListResponse struct {
	// Plugins List of plugin summaries
	Plugins []PluginSummary `json:"plugins"`
}

// PluginSource Plugin source configuration
type PluginSource struct {
	// Checksum Expected SHA256 hash of the JAR file (for url type).
	// If not provided, downloads will not be verified.
	Checksum *string `json:"checksum,omitempty"`

	// Project Project identifier in the repository.
	// Required for hangar type.
	Project *string `json:"project,omitempty"`

	// Type Type of plugin repository.
	//
	// - **hangar**: PaperMC Hangar repository (hangar.papermc.io)
	// - **url**: Direct URL download (no version management)
	Type PluginSourceType `json:"type"`

	// Url Direct download URL.
	// Required for url type.
	Url *string `json:"url,omitempty"`
}

// PluginSourceType Type of plugin repository.
//
// - **hangar**: PaperMC Hangar repository (hangar.papermc.io)
// - **url**: Direct URL download (no version management)
type PluginSourceType string

// PluginSummary Summary information about a Plugin
type PluginSummary struct {
	// Build Pinned build number (for build-pin strategy)
	Build *int `json:"build,omitempty"`

	// MatchedServers Number of servers this plugin is matched to
	MatchedServers *int `json:"matchedServers,omitempty"`

	// Name Kubernetes resource name
	Name string `json:"name"`

	// Namespace Kubernetes namespace
	Namespace string `json:"namespace"`

	// Project Project identifier in the repository
	Project *string `json:"project,omitempty"`

	// RepositoryStatus Status of the plugin repository connection.
	//
	// - **available**: Repository is accessible and returning metadata
	// - **unavailable**: Repository is temporarily unavailable (using cached data)
	// - **orphaned**: Plugin source no longer exists in repository
	RepositoryStatus *RepositoryStatus `json:"repositoryStatus,omitempty"`

	// ResolvedVersion Version resolved by the constraint solver
	ResolvedVersion *string `json:"resolvedVersion,omitempty"`

	// SourceType Type of plugin repository.
	//
	// - **hangar**: PaperMC Hangar repository (hangar.papermc.io)
	// - **url**: Direct URL download (no version management)
	SourceType PluginSourceType `json:"sourceType"`

	// UpdateStrategy Defines how versions are managed for servers and plugins.
	//
	// - **latest**: Always use the latest available version from the repository
	// - **auto**: Use constraint solver to find best version compatible with all dependencies
	// - **pin**: Pin to specific version, auto-update to latest build within that version
	// - **build-pin**: Pin to specific version AND build number, no automatic updates
	UpdateStrategy UpdateStrategy `json:"updateStrategy"`

	// Url Direct download URL (for type=url)
	Url *string `json:"url,omitempty"`

	// Version Pinned version (for pin/build-pin strategies)
	Version *string `json:"version,omitempty"`
}

// PluginUpdateRequest Request body for updating an existing Plugin
type PluginUpdateRequest struct {
	// Build Pinned build number
	Build *int `json:"build,omitempty"`

	// CompatibilityOverride Manual compatibility specification
	CompatibilityOverride *CompatibilityOverride `json:"compatibilityOverride,omitempty"`

	// InstanceSelector Kubernetes label selector
	InstanceSelector *LabelSelector `json:"instanceSelector,omitempty"`

	// Port Network port to expose
	Port *int `json:"port,omitempty"`

	// Source Plugin source configuration
	Source *PluginSource `json:"source,omitempty"`

	// UpdateDelay Grace period before applying updates
	UpdateDelay *string `json:"updateDelay,omitempty"`

	// UpdateStrategy Defines how versions are managed for servers and plugins.
	//
	// - **latest**: Always use the latest available version from the repository
	// - **auto**: Use constraint solver to find best version compatible with all dependencies
	// - **pin**: Pin to specific version, auto-update to latest build within that version
	// - **build-pin**: Pin to specific version AND build number, no automatic updates
	UpdateStrategy *UpdateStrategy `json:"updateStrategy,omitempty"`

	// Version Pinned version
	Version *string `json:"version,omitempty"`
}

// PluginVersion Metadata about a specific plugin version
type PluginVersion struct {
	// CachedAt When this metadata was cached
	CachedAt *time.Time `json:"cachedAt,omitempty"`

	// DownloadUrl URL to download this version
	DownloadUrl string `json:"downloadUrl"`

	// Hash SHA256 hash of the JAR file
	Hash *string `json:"hash,omitempty"`

	// MinecraftVersions Compatible Minecraft versions
	MinecraftVersions []string `json:"minecraftVersions"`

	// ReleasedAt When this version was released
	ReleasedAt *time.Time `json:"releasedAt,omitempty"`

	// Version Plugin version string
	Version string `json:"version"`
}

// PluginVersionPair A plugin paired with its version for an update
type PluginVersionPair struct {
	// Name Plugin name
	Name *string `json:"name,omitempty"`

	// Namespace Plugin namespace
	Namespace *string `json:"namespace,omitempty"`

	// Version Plugin version
	Version *string `json:"version,omitempty"`
}

// RCONConfig RCON configuration for create/update requests
type RCONConfig struct {
	// Enabled Whether RCON is enabled
	Enabled *bool `json:"enabled,omitempty"`

	// PasswordSecretKey Key within the Secret containing the password
	PasswordSecretKey *string `json:"passwordSecretKey,omitempty"`

	// PasswordSecretName Name of the Secret containing the RCON password
	PasswordSecretName *string `json:"passwordSecretName,omitempty"`

	// Port RCON port
	Port *int `json:"port,omitempty"`
}

// RCONStatus RCON status information
type RCONStatus struct {
	// Enabled Whether RCON is enabled
	Enabled *bool `json:"enabled,omitempty"`

	// Port RCON port
	Port *int `json:"port,omitempty"`
}

// RepositoryStatus Status of the plugin repository connection.
//
// - **available**: Repository is accessible and returning metadata
// - **unavailable**: Repository is temporarily unavailable (using cached data)
// - **orphaned**: Plugin source no longer exists in repository
type RepositoryStatus string

// ServerCreateRequest Request body for creating a new PaperMCServer
type ServerCreateRequest struct {
	// Build Target Paper build number (required for build-pin strategy).
	// For pin strategy, serves as minimum build.
	Build *int `json:"build,omitempty"`

	// CheckCron Cron expression for update checks.
	// Format: minute hour day month weekday
	CheckCron *string `json:"checkCron,omitempty"`

	// GracefulShutdownTimeout Graceful shutdown timeout (Go duration format).
	// Must match StatefulSet terminationGracePeriodSeconds.
	GracefulShutdownTimeout *string `json:"gracefulShutdownTimeout,omitempty"`

	// Labels Labels to apply to the server resource
	Labels *map[string]string `json:"labels,omitempty"`

	// MaintenanceWindow Maintenance window configuration for create/update requests
	MaintenanceWindow *MaintenanceWindowConfig `json:"maintenanceWindow,omitempty"`

	// Name Kubernetes resource name (must be valid DNS subdomain)
	Name string `json:"name"`

	// Namespace Kubernetes namespace to create the server in
	Namespace string `json:"namespace"`

	// Rcon RCON configuration for create/update requests
	Rcon *RCONConfig `json:"rcon,omitempty"`

	// Service Kubernetes Service configuration
	Service *ServiceConfig `json:"service,omitempty"`

	// UpdateDelay Grace period before applying updates (Go duration format).
	// Examples: "168h" (7 days), "24h", "30m"
	UpdateDelay *string `json:"updateDelay,omitempty"`

	// UpdateStrategy Defines how versions are managed for servers and plugins.
	//
	// - **latest**: Always use the latest available version from the repository
	// - **auto**: Use constraint solver to find best version compatible with all dependencies
	// - **pin**: Pin to specific version, auto-update to latest build within that version
	// - **build-pin**: Pin to specific version AND build number, no automatic updates
	UpdateStrategy UpdateStrategy `json:"updateStrategy"`

	// Version Target Paper version (required for pin and build-pin strategies).
	// Example: "1.21.1" for Minecraft 1.21.1
	Version *string `json:"version,omitempty"`
}

// ServerDetail defines model for ServerDetail.
type ServerDetail struct {
	// AvailableUpdate Information about an available update
	AvailableUpdate *AvailableUpdate `json:"availableUpdate,omitempty"`

	// Conditions Kubernetes conditions for the server
	Conditions *[]Condition `json:"conditions,omitempty"`

	// CurrentBuild Currently running Paper build number
	CurrentBuild *int `json:"currentBuild,omitempty"`

	// CurrentVersion Currently running Paper version with build number (e.g., "1.21.1-100")
	CurrentVersion *string `json:"currentVersion,omitempty"`

	// DesiredBuild Target Paper build number
	DesiredBuild *int `json:"desiredBuild,omitempty"`

	// DesiredVersion Target Paper version the operator wants to run
	DesiredVersion *string `json:"desiredVersion,omitempty"`

	// Labels Kubernetes labels from the server resource
	Labels *map[string]string `json:"labels,omitempty"`

	// LastUpdate Record of the last update attempt
	LastUpdate *UpdateHistory `json:"lastUpdate,omitempty"`

	// MaintenanceSchedule Maintenance schedule configuration
	MaintenanceSchedule *MaintenanceSchedule `json:"maintenanceSchedule,omitempty"`

	// Name Kubernetes resource name
	Name string `json:"name"`

	// Namespace Kubernetes namespace
	Namespace string `json:"namespace"`

	// NextMaintenance Human-readable description of next maintenance window
	NextMaintenance *string `json:"nextMaintenance,omitempty"`

	// PluginCount Number of plugins matched to this server
	PluginCount *int `json:"pluginCount,omitempty"`

	// Plugins List of plugins matched to this server
	Plugins *[]ServerPlugin `json:"plugins,omitempty"`

	// Rcon RCON status information
	Rcon *RCONStatus `json:"rcon,omitempty"`

	// Service Service status information
	Service *ServiceStatus `json:"service,omitempty"`

	// Status Current operational status of the server.
	//
	// - **running**: Server is running normally with all replicas ready
	// - **updating**: Server is being updated (StatefulSet rolling update in progress)
	// - **unknown**: Status cannot be determined (no condition or StatefulSet data)
	Status ServerStatus `json:"status"`

	// UpdateBlocked Information about blocked updates
	UpdateBlocked *UpdateBlockedStatus `json:"updateBlocked,omitempty"`

	// UpdateStrategy Defines how versions are managed for servers and plugins.
	//
	// - **latest**: Always use the latest available version from the repository
	// - **auto**: Use constraint solver to find best version compatible with all dependencies
	// - **pin**: Pin to specific version, auto-update to latest build within that version
	// - **build-pin**: Pin to specific version AND build number, no automatic updates
	UpdateStrategy UpdateStrategy `json:"updateStrategy"`
}

// ServerListResponse defines model for ServerListResponse.
type ServerListResponse struct {
	// Servers List of server summaries
	Servers []ServerSummary `json:"servers"`
}

// ServerPlugin Status of a plugin on a specific server
type ServerPlugin struct {
	// Compatible Whether the plugin is compatible with the server version
	Compatible bool `json:"compatible"`

	// CurrentVersion Currently installed version on the server
	CurrentVersion *string `json:"currentVersion,omitempty"`

	// DesiredVersion Target version to install
	DesiredVersion *string `json:"desiredVersion,omitempty"`

	// InstalledJarName Filename of the installed JAR in /data/plugins/
	InstalledJarName *string `json:"installedJarName,omitempty"`

	// Name Plugin resource name
	Name string `json:"name"`

	// Namespace Plugin resource namespace
	Namespace *string `json:"namespace,omitempty"`

	// PendingDeletion Whether the plugin is marked for removal
	PendingDeletion *bool `json:"pendingDeletion,omitempty"`

	// Project Project identifier in the repository
	Project *string `json:"project,omitempty"`

	// ResolvedVersion Version resolved by the constraint solver
	ResolvedVersion *string `json:"resolvedVersion,omitempty"`

	// Source Plugin source type
	Source *string `json:"source,omitempty"`
}

// ServerStatus Current operational status of the server.
//
// - **running**: Server is running normally with all replicas ready
// - **updating**: Server is being updated (StatefulSet rolling update in progress)
// - **unknown**: Status cannot be determined (no condition or StatefulSet data)
type ServerStatus string

// ServerSummary Summary information about a PaperMCServer
type ServerSummary struct {
	// AvailableUpdate Information about an available update
	AvailableUpdate *AvailableUpdate `json:"availableUpdate,omitempty"`

	// CurrentVersion Currently running Paper version with build number (e.g., "1.21.1-100")
	CurrentVersion *string `json:"currentVersion,omitempty"`

	// DesiredVersion Target Paper version the operator wants to run
	DesiredVersion *string `json:"desiredVersion,omitempty"`

	// Labels Kubernetes labels from the server resource
	Labels *map[string]string `json:"labels,omitempty"`

	// Name Kubernetes resource name
	Name string `json:"name"`

	// Namespace Kubernetes namespace
	Namespace string `json:"namespace"`

	// NextMaintenance Human-readable description of next maintenance window
	NextMaintenance *string `json:"nextMaintenance,omitempty"`

	// PluginCount Number of plugins matched to this server
	PluginCount *int `json:"pluginCount,omitempty"`

	// Status Current operational status of the server.
	//
	// - **running**: Server is running normally with all replicas ready
	// - **updating**: Server is being updated (StatefulSet rolling update in progress)
	// - **unknown**: Status cannot be determined (no condition or StatefulSet data)
	Status ServerStatus `json:"status"`

	// UpdateStrategy Defines how versions are managed for servers and plugins.
	//
	// - **latest**: Always use the latest available version from the repository
	// - **auto**: Use constraint solver to find best version compatible with all dependencies
	// - **pin**: Pin to specific version, auto-update to latest build within that version
	// - **build-pin**: Pin to specific version AND build number, no automatic updates
	UpdateStrategy UpdateStrategy `json:"updateStrategy"`
}

// ServerUpdateRequest Request body for updating an existing PaperMCServer
type ServerUpdateRequest struct {
	// Build Target Paper build number
	Build *int `json:"build,omitempty"`

	// CheckCron Cron expression for update checks
	CheckCron *string `json:"checkCron,omitempty"`

	// Labels Labels to set on the server resource
	Labels *map[string]string `json:"labels,omitempty"`

	// MaintenanceWindow Maintenance window configuration for create/update requests
	MaintenanceWindow *MaintenanceWindowConfig `json:"maintenanceWindow,omitempty"`

	// UpdateDelay Grace period before applying updates
	UpdateDelay *string `json:"updateDelay,omitempty"`

	// UpdateStrategy Defines how versions are managed for servers and plugins.
	//
	// - **latest**: Always use the latest available version from the repository
	// - **auto**: Use constraint solver to find best version compatible with all dependencies
	// - **pin**: Pin to specific version, auto-update to latest build within that version
	// - **build-pin**: Pin to specific version AND build number, no automatic updates
	UpdateStrategy *UpdateStrategy `json:"updateStrategy,omitempty"`

	// Version Target Paper version
	Version *string `json:"version,omitempty"`
}

// ServiceConfig Kubernetes Service configuration
type ServiceConfig struct {
	// Annotations Custom annotations for the Service
	Annotations *map[string]string `json:"annotations,omitempty"`

	// LoadBalancerIP Static IP for LoadBalancer type
	LoadBalancerIP *string `json:"loadBalancerIP,omitempty"`

	// Type Kubernetes Service type for the server.
	//
	// - **LoadBalancer**: External load balancer (requires cloud provider or MetalLB)
	// - **NodePort**: Expose on a static port on each node
	// - **ClusterIP**: Internal cluster IP only
	Type *ServiceType `json:"type,omitempty"`
}

// ServiceStatus Service status information
type ServiceStatus struct {
	// ClusterIP Cluster IP address
	ClusterIP *string `json:"clusterIP,omitempty"`

	// ExternalIP External IP address (for LoadBalancer)
	ExternalIP *string `json:"externalIP,omitempty"`

	// Type Kubernetes Service type for the server.
	//
	// - **LoadBalancer**: External load balancer (requires cloud provider or MetalLB)
	// - **NodePort**: Expose on a static port on each node
	// - **ClusterIP**: Internal cluster IP only
	Type *ServiceType `json:"type,omitempty"`
}

// ServiceType Kubernetes Service type for the server.
//
// - **LoadBalancer**: External load balancer (requires cloud provider or MetalLB)
// - **NodePort**: Expose on a static port on each node
// - **ClusterIP**: Internal cluster IP only
type ServiceType string

// UpdateBlockedStatus Information about blocked updates
type UpdateBlockedStatus struct {
	// Blocked Whether updates are currently blocked
	Blocked *bool `json:"blocked,omitempty"`

	// BlockedBy Details about what is blocking an update
	BlockedBy *BlockedByInfo `json:"blockedBy,omitempty"`

	// Reason Human-readable reason for the block
	Reason *string `json:"reason,omitempty"`
}

// UpdateHistory Record of the last update attempt
type UpdateHistory struct {
	// AppliedAt When the update was applied
	AppliedAt *time.Time `json:"appliedAt,omitempty"`

	// PreviousVersion Version before the update
	PreviousVersion *string `json:"previousVersion,omitempty"`

	// Successful Whether the update succeeded
	Successful *bool `json:"successful,omitempty"`
}

// UpdateStrategy Defines how versions are managed for servers and plugins.
//
// - **latest**: Always use the latest available version from the repository
// - **auto**: Use constraint solver to find best version compatible with all dependencies
// - **pin**: Pin to specific version, auto-update to latest build within that version
// - **build-pin**: Pin to specific version AND build number, no automatic updates
type UpdateStrategy string

// VersionResponse Version information about the operator
type VersionResponse struct {
	// ApiVersion API version
	ApiVersion string `json:"apiVersion"`

	// BuildDate Date and time when the operator was built
	BuildDate *time.Time `json:"buildDate,omitempty"`

	// GitCommit Git commit hash of the build
	GitCommit *string `json:"gitCommit,omitempty"`

	// GoVersion Go version used to build the operator
	GoVersion *string `json:"goVersion,omitempty"`

	// Version Semantic version of the operator
	Version string `json:"version"`
}

// Namespace defines model for Namespace.
type Namespace = string

// PluginName defines model for PluginName.
type PluginName = string

// ServerName defines model for ServerName.
type ServerName = string

// BadRequest Error response body
type BadRequest = ErrorResponse

// Conflict Error response body
type Conflict = ErrorResponse

// InternalServerError Error response body
type InternalServerError = ErrorResponse

// NotFound Error response body
type NotFound = ErrorResponse

// ListPluginsParams defines parameters for ListPlugins.
type ListPluginsParams struct {
	// Namespace Filter plugins by Kubernetes namespace
	Namespace *string `form:"namespace,omitempty" json:"namespace,omitempty"`
}

// ListServersParams defines parameters for ListServers.
type ListServersParams struct {
	// Namespace Filter servers by Kubernetes namespace
	Namespace *string `form:"namespace,omitempty" json:"namespace,omitempty"`
}

// CreatePluginJSONRequestBody defines body for CreatePlugin for application/json ContentType.
type CreatePluginJSONRequestBody = PluginCreateRequest

// UpdatePluginJSONRequestBody defines body for UpdatePlugin for application/json ContentType.
type UpdatePluginJSONRequestBody = PluginUpdateRequest

// CreateServerJSONRequestBody defines body for CreateServer for application/json ContentType.
type CreateServerJSONRequestBody = ServerCreateRequest

// UpdateServerJSONRequestBody defines body for UpdateServer for application/json ContentType.
type UpdateServerJSONRequestBody = ServerUpdateRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Health check endpoint
	// (GET /health)
	GetHealth(w http.ResponseWriter, r *http.Request)
	// List available namespaces
	// (GET /namespaces)
	ListNamespaces(w http.ResponseWriter, r *http.Request)
	// List all plugins
	// (GET /plugins)
	ListPlugins(w http.ResponseWriter, r *http.Request, params ListPluginsParams)
	// Create a new plugin
	// (POST /plugins)
	CreatePlugin(w http.ResponseWriter, r *http.Request)
	// Delete a plugin
	// (DELETE /plugins/{namespace}/{name})
	DeletePlugin(w http.ResponseWriter, r *http.Request, namespace Namespace, name PluginName)
	// Get a specific plugin
	// (GET /plugins/{namespace}/{name})
	GetPlugin(w http.ResponseWriter, r *http.Request, namespace Namespace, name PluginName)
	// Update a plugin
	// (PUT /plugins/{namespace}/{name})
	UpdatePlugin(w http.ResponseWriter, r *http.Request, namespace Namespace, name PluginName)
	// Trigger plugin reconciliation
	// (POST /plugins/{namespace}/{name}/actions/resolve)
	ResolvePlugin(w http.ResponseWriter, r *http.Request, namespace Namespace, name PluginName)
	// List all PaperMC servers
	// (GET /servers)
	ListServers(w http.ResponseWriter, r *http.Request, params ListServersParams)
	// Create a new PaperMC server
	// (POST /servers)
	CreateServer(w http.ResponseWriter, r *http.Request)
	// Delete a server
	// (DELETE /servers/{namespace}/{name})
	DeleteServer(w http.ResponseWriter, r *http.Request, namespace Namespace, name ServerName)
	// Get a specific server
	// (GET /servers/{namespace}/{name})
	GetServer(w http.ResponseWriter, r *http.Request, namespace Namespace, name ServerName)
	// Update a server
	// (PUT /servers/{namespace}/{name})
	UpdateServer(w http.ResponseWriter, r *http.Request, namespace Namespace, name ServerName)
	// Apply pending updates immediately
	// (POST /servers/{namespace}/{name}/actions/apply-now)
	ApplyNowServer(w http.ResponseWriter, r *http.Request, namespace Namespace, name ServerName)
	// Trigger server reconciliation
	// (POST /servers/{namespace}/{name}/actions/resolve)
	ResolveServer(w http.ResponseWriter, r *http.Request, namespace Namespace, name ServerName)
	// Get API version information
	// (GET /version)
	GetVersion(w http.ResponseWriter, r *http.Request)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// GetHealth operation middleware
func (siw *ServerInterfaceWrapper) GetHealth(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetHealth(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListNamespaces operation middleware
func (siw *ServerInterfaceWrapper) ListNamespaces(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListNamespaces(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListPlugins operation middleware
func (siw *ServerInterfaceWrapper) ListPlugins(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListPluginsParams

	// ------------- Optional query parameter "namespace" -------------

	err = runtime.BindQueryParameter("form", true, false, "namespace", r.URL.Query(), &params.Namespace)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "namespace", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListPlugins(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreatePlugin operation middleware
func (siw *ServerInterfaceWrapper) CreatePlugin(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreatePlugin(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeletePlugin operation middleware
func (siw *ServerInterfaceWrapper) DeletePlugin(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "namespace" -------------
	var namespace Namespace

	err = runtime.BindStyledParameterWithOptions("simple", "namespace", r.PathValue("namespace"), &namespace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "namespace", Err: err})
		return
	}

	// ------------- Path parameter "name" -------------
	var name PluginName

	err = runtime.BindStyledParameterWithOptions("simple", "name", r.PathValue("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeletePlugin(w, r, namespace, name)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetPlugin operation middleware
func (siw *ServerInterfaceWrapper) GetPlugin(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "namespace" -------------
	var namespace Namespace

	err = runtime.BindStyledParameterWithOptions("simple", "namespace", r.PathValue("namespace"), &namespace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "namespace", Err: err})
		return
	}

	// ------------- Path parameter "name" -------------
	var name PluginName

	err = runtime.BindStyledParameterWithOptions("simple", "name", r.PathValue("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetPlugin(w, r, namespace, name)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdatePlugin operation middleware
func (siw *ServerInterfaceWrapper) UpdatePlugin(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "namespace" -------------
	var namespace Namespace

	err = runtime.BindStyledParameterWithOptions("simple", "namespace", r.PathValue("namespace"), &namespace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "namespace", Err: err})
		return
	}

	// ------------- Path parameter "name" -------------
	var name PluginName

	err = runtime.BindStyledParameterWithOptions("simple", "name", r.PathValue("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdatePlugin(w, r, namespace, name)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ResolvePlugin operation middleware
func (siw *ServerInterfaceWrapper) ResolvePlugin(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "namespace" -------------
	var namespace Namespace

	err = runtime.BindStyledParameterWithOptions("simple", "namespace", r.PathValue("namespace"), &namespace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "namespace", Err: err})
		return
	}

	// ------------- Path parameter "name" -------------
	var name PluginName

	err = runtime.BindStyledParameterWithOptions("simple", "name", r.PathValue("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ResolvePlugin(w, r, namespace, name)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListServers operation middleware
func (siw *ServerInterfaceWrapper) ListServers(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListServersParams

	// ------------- Optional query parameter "namespace" -------------

	err = runtime.BindQueryParameter("form", true, false, "namespace", r.URL.Query(), &params.Namespace)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "namespace", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListServers(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateServer operation middleware
func (siw *ServerInterfaceWrapper) CreateServer(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateServer(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteServer operation middleware
func (siw *ServerInterfaceWrapper) DeleteServer(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "namespace" -------------
	var namespace Namespace

	err = runtime.BindStyledParameterWithOptions("simple", "namespace", r.PathValue("namespace"), &namespace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "namespace", Err: err})
		return
	}

	// ------------- Path parameter "name" -------------
	var name ServerName

	err = runtime.BindStyledParameterWithOptions("simple", "name", r.PathValue("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteServer(w, r, namespace, name)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetServer operation middleware
func (siw *ServerInterfaceWrapper) GetServer(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "namespace" -------------
	var namespace Namespace

	err = runtime.BindStyledParameterWithOptions("simple", "namespace", r.PathValue("namespace"), &namespace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "namespace", Err: err})
		return
	}

	// ------------- Path parameter "name" -------------
	var name ServerName

	err = runtime.BindStyledParameterWithOptions("simple", "name", r.PathValue("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetServer(w, r, namespace, name)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateServer operation middleware
func (siw *ServerInterfaceWrapper) UpdateServer(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "namespace" -------------
	var namespace Namespace

	err = runtime.BindStyledParameterWithOptions("simple", "namespace", r.PathValue("namespace"), &namespace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "namespace", Err: err})
		return
	}

	// ------------- Path parameter "name" -------------
	var name ServerName

	err = runtime.BindStyledParameterWithOptions("simple", "name", r.PathValue("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateServer(w, r, namespace, name)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ApplyNowServer operation middleware
func (siw *ServerInterfaceWrapper) ApplyNowServer(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "namespace" -------------
	var namespace Namespace

	err = runtime.BindStyledParameterWithOptions("simple", "namespace", r.PathValue("namespace"), &namespace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "namespace", Err: err})
		return
	}

	// ------------- Path parameter "name" -------------
	var name ServerName

	err = runtime.BindStyledParameterWithOptions("simple", "name", r.PathValue("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ApplyNowServer(w, r, namespace, name)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ResolveServer operation middleware
func (siw *ServerInterfaceWrapper) ResolveServer(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "namespace" -------------
	var namespace Namespace

	err = runtime.BindStyledParameterWithOptions("simple", "namespace", r.PathValue("namespace"), &namespace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "namespace", Err: err})
		return
	}

	// ------------- Path parameter "name" -------------
	var name ServerName

	err = runtime.BindStyledParameterWithOptions("simple", "name", r.PathValue("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ResolveServer(w, r, namespace, name)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetVersion operation middleware
func (siw *ServerInterfaceWrapper) GetVersion(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetVersion(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("GET "+options.BaseURL+"/health", wrapper.GetHealth)
	m.HandleFunc("GET "+options.BaseURL+"/namespaces", wrapper.ListNamespaces)
	m.HandleFunc("GET "+options.BaseURL+"/plugins", wrapper.ListPlugins)
	m.HandleFunc("POST "+options.BaseURL+"/plugins", wrapper.CreatePlugin)
	m.HandleFunc("DELETE "+options.BaseURL+"/plugins/{namespace}/{name}", wrapper.DeletePlugin)
	m.HandleFunc("GET "+options.BaseURL+"/plugins/{namespace}/{name}", wrapper.GetPlugin)
	m.HandleFunc("PUT "+options.BaseURL+"/plugins/{namespace}/{name}", wrapper.UpdatePlugin)
	m.HandleFunc("POST "+options.BaseURL+"/plugins/{namespace}/{name}/actions/resolve", wrapper.ResolvePlugin)
	m.HandleFunc("GET "+options.BaseURL+"/servers", wrapper.ListServers)
	m.HandleFunc("POST "+options.BaseURL+"/servers", wrapper.CreateServer)
	m.HandleFunc("DELETE "+options.BaseURL+"/servers/{namespace}/{name}", wrapper.DeleteServer)
	m.HandleFunc("GET "+options.BaseURL+"/servers/{namespace}/{name}", wrapper.GetServer)
	m.HandleFunc("PUT "+options.BaseURL+"/servers/{namespace}/{name}", wrapper.UpdateServer)
	m.HandleFunc("POST "+options.BaseURL+"/servers/{namespace}/{name}/actions/apply-now", wrapper.ApplyNowServer)
	m.HandleFunc("POST "+options.BaseURL+"/servers/{namespace}/{name}/actions/resolve", wrapper.ResolveServer)
	m.HandleFunc("GET "+options.BaseURL+"/version", wrapper.GetVersion)

	return m
}

type BadRequestJSONResponse ErrorResponse

type ConflictJSONResponse ErrorResponse

type InternalServerErrorJSONResponse ErrorResponse

type NotFoundJSONResponse ErrorResponse

type GetHealthRequestObject struct {
}

type GetHealthResponseObject interface {
	VisitGetHealthResponse(w http.ResponseWriter) error
}

type GetHealth200JSONResponse HealthResponse

func (response GetHealth200JSONResponse) VisitGetHealthResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetHealth503JSONResponse HealthResponse

func (response GetHealth503JSONResponse) VisitGetHealthResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(503)

	return json.NewEncoder(w).Encode(response)
}

type ListNamespacesRequestObject struct {
}

type ListNamespacesResponseObject interface {
	VisitListNamespacesResponse(w http.ResponseWriter) error
}

type ListNamespaces200JSONResponse NamespaceListResponse

func (response ListNamespaces200JSONResponse) VisitListNamespacesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListNamespaces500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response ListNamespaces500JSONResponse) VisitListNamespacesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type ListPluginsRequestObject struct {
	Params ListPluginsParams
}

type ListPluginsResponseObject interface {
	VisitListPluginsResponse(w http.ResponseWriter) error
}

type ListPlugins200JSONResponse PluginListResponse

func (response ListPlugins200JSONResponse) VisitListPluginsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListPlugins500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response ListPlugins500JSONResponse) VisitListPluginsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type CreatePluginRequestObject struct {
	Body *CreatePluginJSONRequestBody
}

type CreatePluginResponseObject interface {
	VisitCreatePluginResponse(w http.ResponseWriter) error
}

type CreatePlugin201JSONResponse PluginDetail

func (response CreatePlugin201JSONResponse) VisitCreatePluginResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type CreatePlugin400JSONResponse struct{ BadRequestJSONResponse }

func (response CreatePlugin400JSONResponse) VisitCreatePluginResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type CreatePlugin409JSONResponse struct{ ConflictJSONResponse }

func (response CreatePlugin409JSONResponse) VisitCreatePluginResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(409)

	return json.NewEncoder(w).Encode(response)
}

type CreatePlugin500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response CreatePlugin500JSONResponse) VisitCreatePluginResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type DeletePluginRequestObject struct {
	Namespace Namespace  `json:"namespace"`
	Name      PluginName `json:"name"`
}

type DeletePluginResponseObject interface {
	VisitDeletePluginResponse(w http.ResponseWriter) error
}

type DeletePlugin204Response struct {
}

func (response DeletePlugin204Response) VisitDeletePluginResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type DeletePlugin404JSONResponse struct{ NotFoundJSONResponse }

func (response DeletePlugin404JSONResponse) VisitDeletePluginResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type DeletePlugin500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response DeletePlugin500JSONResponse) VisitDeletePluginResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GetPluginRequestObject struct {
	Namespace Namespace  `json:"namespace"`
	Name      PluginName `json:"name"`
}

type GetPluginResponseObject interface {
	VisitGetPluginResponse(w http.ResponseWriter) error
}

type GetPlugin200JSONResponse PluginDetail

func (response GetPlugin200JSONResponse) VisitGetPluginResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetPlugin404JSONResponse struct{ NotFoundJSONResponse }

func (response GetPlugin404JSONResponse) VisitGetPluginResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type GetPlugin500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response GetPlugin500JSONResponse) VisitGetPluginResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type UpdatePluginRequestObject struct {
	Namespace Namespace  `json:"namespace"`
	Name      PluginName `json:"name"`
	Body      *UpdatePluginJSONRequestBody
}

type UpdatePluginResponseObject interface {
	VisitUpdatePluginResponse(w http.ResponseWriter) error
}

type UpdatePlugin200JSONResponse PluginDetail

func (response UpdatePlugin200JSONResponse) VisitUpdatePluginResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type UpdatePlugin400JSONResponse struct{ BadRequestJSONResponse }

func (response UpdatePlugin400JSONResponse) VisitUpdatePluginResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type UpdatePlugin404JSONResponse struct{ NotFoundJSONResponse }

func (response UpdatePlugin404JSONResponse) VisitUpdatePluginResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type UpdatePlugin500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response UpdatePlugin500JSONResponse) VisitUpdatePluginResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type ResolvePluginRequestObject struct {
	Namespace Namespace  `json:"namespace"`
	Name      PluginName `json:"name"`
}

type ResolvePluginResponseObject interface {
	VisitResolvePluginResponse(w http.ResponseWriter) error
}

type ResolvePlugin202JSONResponse ActionResponse

func (response ResolvePlugin202JSONResponse) VisitResolvePluginResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(202)

	return json.NewEncoder(w).Encode(response)
}

type ResolvePlugin404JSONResponse struct{ NotFoundJSONResponse }

func (response ResolvePlugin404JSONResponse) VisitResolvePluginResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type ResolvePlugin500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response ResolvePlugin500JSONResponse) VisitResolvePluginResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type ListServersRequestObject struct {
	Params ListServersParams
}

type ListServersResponseObject interface {
	VisitListServersResponse(w http.ResponseWriter) error
}

type ListServers200JSONResponse ServerListResponse

func (response ListServers200JSONResponse) VisitListServersResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListServers500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response ListServers500JSONResponse) VisitListServersResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type CreateServerRequestObject struct {
	Body *CreateServerJSONRequestBody
}

type CreateServerResponseObject interface {
	VisitCreateServerResponse(w http.ResponseWriter) error
}

type CreateServer201JSONResponse ServerDetail

func (response CreateServer201JSONResponse) VisitCreateServerResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type CreateServer400JSONResponse struct{ BadRequestJSONResponse }

func (response CreateServer400JSONResponse) VisitCreateServerResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type CreateServer409JSONResponse struct{ ConflictJSONResponse }

func (response CreateServer409JSONResponse) VisitCreateServerResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(409)

	return json.NewEncoder(w).Encode(response)
}

type CreateServer500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response CreateServer500JSONResponse) VisitCreateServerResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type DeleteServerRequestObject struct {
	Namespace Namespace  `json:"namespace"`
	Name      ServerName `json:"name"`
}

type DeleteServerResponseObject interface {
	VisitDeleteServerResponse(w http.ResponseWriter) error
}

type DeleteServer204Response struct {
}

func (response DeleteServer204Response) VisitDeleteServerResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type DeleteServer404JSONResponse struct{ NotFoundJSONResponse }

func (response DeleteServer404JSONResponse) VisitDeleteServerResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type DeleteServer500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response DeleteServer500JSONResponse) VisitDeleteServerResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GetServerRequestObject struct {
	Namespace Namespace  `json:"namespace"`
	Name      ServerName `json:"name"`
}

type GetServerResponseObject interface {
	VisitGetServerResponse(w http.ResponseWriter) error
}

type GetServer200JSONResponse ServerDetail

func (response GetServer200JSONResponse) VisitGetServerResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetServer404JSONResponse struct{ NotFoundJSONResponse }

func (response GetServer404JSONResponse) VisitGetServerResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type GetServer500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response GetServer500JSONResponse) VisitGetServerResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type UpdateServerRequestObject struct {
	Namespace Namespace  `json:"namespace"`
	Name      ServerName `json:"name"`
	Body      *UpdateServerJSONRequestBody
}

type UpdateServerResponseObject interface {
	VisitUpdateServerResponse(w http.ResponseWriter) error
}

type UpdateServer200JSONResponse ServerDetail

func (response UpdateServer200JSONResponse) VisitUpdateServerResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type UpdateServer400JSONResponse struct{ BadRequestJSONResponse }

func (response UpdateServer400JSONResponse) VisitUpdateServerResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type UpdateServer404JSONResponse struct{ NotFoundJSONResponse }

func (response UpdateServer404JSONResponse) VisitUpdateServerResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type UpdateServer500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response UpdateServer500JSONResponse) VisitUpdateServerResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type ApplyNowServerRequestObject struct {
	Namespace Namespace  `json:"namespace"`
	Name      ServerName `json:"name"`
}

type ApplyNowServerResponseObject interface {
	VisitApplyNowServerResponse(w http.ResponseWriter) error
}

type ApplyNowServer202JSONResponse ActionResponse

func (response ApplyNowServer202JSONResponse) VisitApplyNowServerResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(202)

	return json.NewEncoder(w).Encode(response)
}

type ApplyNowServer404JSONResponse struct{ NotFoundJSONResponse }

func (response ApplyNowServer404JSONResponse) VisitApplyNowServerResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type ApplyNowServer500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response ApplyNowServer500JSONResponse) VisitApplyNowServerResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type ResolveServerRequestObject struct {
	Namespace Namespace  `json:"namespace"`
	Name      ServerName `json:"name"`
}

type ResolveServerResponseObject interface {
	VisitResolveServerResponse(w http.ResponseWriter) error
}

type ResolveServer202JSONResponse ActionResponse

func (response ResolveServer202JSONResponse) VisitResolveServerResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(202)

	return json.NewEncoder(w).Encode(response)
}

type ResolveServer404JSONResponse struct{ NotFoundJSONResponse }

func (response ResolveServer404JSONResponse) VisitResolveServerResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type ResolveServer500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response ResolveServer500JSONResponse) VisitResolveServerResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GetVersionRequestObject struct {
}

type GetVersionResponseObject interface {
	VisitGetVersionResponse(w http.ResponseWriter) error
}

type GetVersion200JSONResponse VersionResponse

func (response GetVersion200JSONResponse) VisitGetVersionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// Health check endpoint
	// (GET /health)
	GetHealth(ctx context.Context, request GetHealthRequestObject) (GetHealthResponseObject, error)
	// List available namespaces
	// (GET /namespaces)
	ListNamespaces(ctx context.Context, request ListNamespacesRequestObject) (ListNamespacesResponseObject, error)
	// List all plugins
	// (GET /plugins)
	ListPlugins(ctx context.Context, request ListPluginsRequestObject) (ListPluginsResponseObject, error)
	// Create a new plugin
	// (POST /plugins)
	CreatePlugin(ctx context.Context, request CreatePluginRequestObject) (CreatePluginResponseObject, error)
	// Delete a plugin
	// (DELETE /plugins/{namespace}/{name})
	DeletePlugin(ctx context.Context, request DeletePluginRequestObject) (DeletePluginResponseObject, error)
	// Get a specific plugin
	// (GET /plugins/{namespace}/{name})
	GetPlugin(ctx context.Context, request GetPluginRequestObject) (GetPluginResponseObject, error)
	// Update a plugin
	// (PUT /plugins/{namespace}/{name})
	UpdatePlugin(ctx context.Context, request UpdatePluginRequestObject) (UpdatePluginResponseObject, error)
	// Trigger plugin reconciliation
	// (POST /plugins/{namespace}/{name}/actions/resolve)
	ResolvePlugin(ctx context.Context, request ResolvePluginRequestObject) (ResolvePluginResponseObject, error)
	// List all PaperMC servers
	// (GET /servers)
	ListServers(ctx context.Context, request ListServersRequestObject) (ListServersResponseObject, error)
	// Create a new PaperMC server
	// (POST /servers)
	CreateServer(ctx context.Context, request CreateServerRequestObject) (CreateServerResponseObject, error)
	// Delete a server
	// (DELETE /servers/{namespace}/{name})
	DeleteServer(ctx context.Context, request DeleteServerRequestObject) (DeleteServerResponseObject, error)
	// Get a specific server
	// (GET /servers/{namespace}/{name})
	GetServer(ctx context.Context, request GetServerRequestObject) (GetServerResponseObject, error)
	// Update a server
	// (PUT /servers/{namespace}/{name})
	UpdateServer(ctx context.Context, request UpdateServerRequestObject) (UpdateServerResponseObject, error)
	// Apply pending updates immediately
	// (POST /servers/{namespace}/{name}/actions/apply-now)
	ApplyNowServer(ctx context.Context, request ApplyNowServerRequestObject) (ApplyNowServerResponseObject, error)
	// Trigger server reconciliation
	// (POST /servers/{namespace}/{name}/actions/resolve)
	ResolveServer(ctx context.Context, request ResolveServerRequestObject) (ResolveServerResponseObject, error)
	// Get API version information
	// (GET /version)
	GetVersion(ctx context.Context, request GetVersionRequestObject) (GetVersionResponseObject, error)
}

type StrictHandlerFunc = strictnethttp.StrictHTTPHandlerFunc
type StrictMiddlewareFunc = strictnethttp.StrictHTTPMiddlewareFunc

type StrictHTTPServerOptions struct {
	RequestErrorHandlerFunc  func(w http.ResponseWriter, r *http.Request, err error)
	ResponseErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: StrictHTTPServerOptions{
		RequestErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		},
		ResponseErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusInternalServerError)
		},
	}}
}

func NewStrictHandlerWithOptions(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc, options StrictHTTPServerOptions) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: options}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
	options     StrictHTTPServerOptions
}

// GetHealth operation middleware
func (sh *strictHandler) GetHealth(w http.ResponseWriter, r *http.Request) {
	var request GetHealthRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetHealth(ctx, request.(GetHealthRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetHealth")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetHealthResponseObject); ok {
		if err := validResponse.VisitGetHealthResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListNamespaces operation middleware
func (sh *strictHandler) ListNamespaces(w http.ResponseWriter, r *http.Request) {
	var request ListNamespacesRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ListNamespaces(ctx, request.(ListNamespacesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListNamespaces")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ListNamespacesResponseObject); ok {
		if err := validResponse.VisitListNamespacesResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListPlugins operation middleware
func (sh *strictHandler) ListPlugins(w http.ResponseWriter, r *http.Request, params ListPluginsParams) {
	var request ListPluginsRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ListPlugins(ctx, request.(ListPluginsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListPlugins")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ListPluginsResponseObject); ok {
		if err := validResponse.VisitListPluginsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// CreatePlugin operation middleware
func (sh *strictHandler) CreatePlugin(w http.ResponseWriter, r *http.Request) {
	var request CreatePluginRequestObject

	var body CreatePluginJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.CreatePlugin(ctx, request.(CreatePluginRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CreatePlugin")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(CreatePluginResponseObject); ok {
		if err := validResponse.VisitCreatePluginResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeletePlugin operation middleware
func (sh *strictHandler) DeletePlugin(w http.ResponseWriter, r *http.Request, namespace Namespace, name PluginName) {
	var request DeletePluginRequestObject

	request.Namespace = namespace
	request.Name = name

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.DeletePlugin(ctx, request.(DeletePluginRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeletePlugin")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(DeletePluginResponseObject); ok {
		if err := validResponse.VisitDeletePluginResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetPlugin operation middleware
func (sh *strictHandler) GetPlugin(w http.ResponseWriter, r *http.Request, namespace Namespace, name PluginName) {
	var request GetPluginRequestObject

	request.Namespace = namespace
	request.Name = name

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetPlugin(ctx, request.(GetPluginRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetPlugin")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetPluginResponseObject); ok {
		if err := validResponse.VisitGetPluginResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// UpdatePlugin operation middleware
func (sh *strictHandler) UpdatePlugin(w http.ResponseWriter, r *http.Request, namespace Namespace, name PluginName) {
	var request UpdatePluginRequestObject

	request.Namespace = namespace
	request.Name = name

	var body UpdatePluginJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.UpdatePlugin(ctx, request.(UpdatePluginRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "UpdatePlugin")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(UpdatePluginResponseObject); ok {
		if err := validResponse.VisitUpdatePluginResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ResolvePlugin operation middleware
func (sh *strictHandler) ResolvePlugin(w http.ResponseWriter, r *http.Request, namespace Namespace, name PluginName) {
	var request ResolvePluginRequestObject

	request.Namespace = namespace
	request.Name = name

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ResolvePlugin(ctx, request.(ResolvePluginRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ResolvePlugin")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ResolvePluginResponseObject); ok {
		if err := validResponse.VisitResolvePluginResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListServers operation middleware
func (sh *strictHandler) ListServers(w http.ResponseWriter, r *http.Request, params ListServersParams) {
	var request ListServersRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ListServers(ctx, request.(ListServersRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListServers")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ListServersResponseObject); ok {
		if err := validResponse.VisitListServersResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// CreateServer operation middleware
func (sh *strictHandler) CreateServer(w http.ResponseWriter, r *http.Request) {
	var request CreateServerRequestObject

	var body CreateServerJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.CreateServer(ctx, request.(CreateServerRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CreateServer")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(CreateServerResponseObject); ok {
		if err := validResponse.VisitCreateServerResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteServer operation middleware
func (sh *strictHandler) DeleteServer(w http.ResponseWriter, r *http.Request, namespace Namespace, name ServerName) {
	var request DeleteServerRequestObject

	request.Namespace = namespace
	request.Name = name

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteServer(ctx, request.(DeleteServerRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteServer")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(DeleteServerResponseObject); ok {
		if err := validResponse.VisitDeleteServerResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetServer operation middleware
func (sh *strictHandler) GetServer(w http.ResponseWriter, r *http.Request, namespace Namespace, name ServerName) {
	var request GetServerRequestObject

	request.Namespace = namespace
	request.Name = name

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetServer(ctx, request.(GetServerRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetServer")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetServerResponseObject); ok {
		if err := validResponse.VisitGetServerResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// UpdateServer operation middleware
func (sh *strictHandler) UpdateServer(w http.ResponseWriter, r *http.Request, namespace Namespace, name ServerName) {
	var request UpdateServerRequestObject

	request.Namespace = namespace
	request.Name = name

	var body UpdateServerJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.UpdateServer(ctx, request.(UpdateServerRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "UpdateServer")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(UpdateServerResponseObject); ok {
		if err := validResponse.VisitUpdateServerResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ApplyNowServer operation middleware
func (sh *strictHandler) ApplyNowServer(w http.ResponseWriter, r *http.Request, namespace Namespace, name ServerName) {
	var request ApplyNowServerRequestObject

	request.Namespace = namespace
	request.Name = name

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ApplyNowServer(ctx, request.(ApplyNowServerRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ApplyNowServer")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ApplyNowServerResponseObject); ok {
		if err := validResponse.VisitApplyNowServerResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ResolveServer operation middleware
func (sh *strictHandler) ResolveServer(w http.ResponseWriter, r *http.Request, namespace Namespace, name ServerName) {
	var request ResolveServerRequestObject

	request.Namespace = namespace
	request.Name = name

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ResolveServer(ctx, request.(ResolveServerRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ResolveServer")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ResolveServerResponseObject); ok {
		if err := validResponse.VisitResolveServerResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetVersion operation middleware
func (sh *strictHandler) GetVersion(w http.ResponseWriter, r *http.Request) {
	var request GetVersionRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetVersion(ctx, request.(GetVersionRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetVersion")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetVersionResponseObject); ok {
		if err := validResponse.VisitGetVersionResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}
